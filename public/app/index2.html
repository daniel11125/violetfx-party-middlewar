<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>ìë™ ì „íˆ¬ë ¥ ì¡°íšŒ</title>
  <style>
    body { font-family: 'Nanum Gothic', sans-serif; background: #111; color: #eee; padding: 20px; }
    button { padding: 10px 20px; font-size: 16px; cursor: pointer; }
    pre { background: #222; padding: 15px; white-space: pre-wrap; border: 1px solid #444; border-radius: 6px; }
  </style>
</head>
<body>
  <h2>ğŸ’¾ ìë™ ì „íˆ¬ë ¥ ì¡°íšŒ ë° ì €ì¥</h2>
  <button onclick="saveToServer()">ì„œë²„ì— ì €ì¥í•˜ê¸°</button>
  <pre id="result">â³ ì‹œì‘ ì¤‘...</pre>

<script>
  async function saveToServer() {
    const resultEl = document.getElementById("result");
    const log = (msg) => {
      console.log(msg);
      resultEl.textContent += msg + "\n";
    };

    resultEl.textContent = "ğŸ“¦ ìºë¦­í„° ì¡°íšŒ ì‹œì‘...\n";
    const results = [];

    try {
      // 1. ìºë¦­í„° ë¶ˆëŸ¬ì˜¤ê¸°
      const sheetRes = await fetch("https://api.sheetbest.com/sheets/776e2812-99b8-4f67-ae74-4b0fa2d6a060");
      const characters = await sheetRes.json();
  const testCharacters = characters.slice(0, 2); // ì‹¤ì œ ì ìš©ì‹œ ì „ì²´ë¡œ êµì²´

      for (let c of testCharacters) {
        if (!c.id) continue;
        log(`ğŸ” ${c.id} ì¡°íšŒ ì¤‘...`);

        const data = await fetchRankData(c.id);
        if (data && data.power) {
          results.push(data);
          log(`âœ… ${data.id}: ${data.power}`);
        } else {
          results.push({ id: c.id, error: true });
          log(`âš ï¸ ${c.id} ì¡°íšŒ ì‹¤íŒ¨`);
        }

        await sleep(300);
      }

      // 2. ì‹¤íŒ¨í•œ ìºë¦­í„° ì¬ì‹œë„ ìµœëŒ€ 5íšŒ
      const failed = results.filter(r => r.error);
      log(`\nğŸ” ì‹¤íŒ¨í•œ ìºë¦­í„° ì¬ì‹œë„ (${failed.length}ëª…)`);

      for (let f of failed) {
        const index = results.findIndex(r => r.id === f.id);
        const retryData = await retryUntilSuccess(f.id, 5, 500, log);
        if (retryData && retryData.power && index !== -1) {
          results[index] = retryData;
          log(`ğŸŸ¢ ì¬ì‹œë„ ì„±ê³µ: ${retryData.id} - ${retryData.power}`);
        } else {
          log(`âŒ ì¬ì‹œë„ ì‹¤íŒ¨: ${f.id}`);
        }
      }

      // 3. ì„±ê³µí•œ ê²°ê³¼ë§Œ ì¶”ì¶œ
      const successOnly = results.filter(r => r && !r.error);

      // 4. ì„œë²„ ì €ì¥
      log("\nğŸ’¾ ì„œë²„ì— ì €ì¥ ì¤‘...");
      const saveRes = await fetch("http://localhost:3000/ranksave", {
      //const saveRes = await fetch("https://violetfx-party-middlewar-production.up.railway.app/ranksave", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ data: successOnly })
      });

      const saveData = await saveRes.json();
      log(`ğŸŸ¢ ì €ì¥ ì™„ë£Œ: ${saveData.count}ëª…\n`);

    } catch (err) {
      console.error("âŒ ì˜¤ë¥˜:", err);
      resultEl.textContent += "âŒ ì˜¤ë¥˜ ë°œìƒ: " + err.message;
    }
  }

  async function fetchRankData(id) {
    try {
      const res = await fetch("http://localhost:3000/rankget", {
      //const res = await fetch("https://violetfx-party-middlewar-production.up.railway.app/rankget", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ id })
      });
      const raw = await res.json();
      return raw.results?.[0];
    } catch {
      return null;
    }
  }

  async function retryUntilSuccess(id, maxRetries, delay, logFn) {
    for (let i = 1; i <= maxRetries; i++) {
      logFn(`ğŸ” (${i}/${maxRetries}) ${id} ì¬ì‹œë„ ì¤‘...`);
      const data = await fetchRankData(id);
      if (data && data.power) return data;
      await sleep(delay);
    }
    return null;
  }

  function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
</script>


</body>
</html>
